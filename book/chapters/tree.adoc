= Tree

A tree is a non-linear data structure where node can have zero or more nodes. The first node in a tree is called *root*. The linked nodes to the root is called *children* or *descendants*.

.Tree Data Structure: root node and descendants.
image:image31.jpg[image,width=404,height=240]

They are called “trees” because the data structure resembles a tree . It starts with a *root* node and *branch* off with its descendants, and finally, there are *leaves*.

== Implementing a Tree

Implementing a tree is not that hard. It’s similar to a Linked List but the difference is that instead of having only a next and previous links, we have an array of linked nodes (children).


.Tree's node constructor
[source, javascript]
----
include::{codedir}/data-structures/trees/tree-node.js[tag=snippet]
  }

  // ... methods goes here ...
}
----

Simple! Right? But there are some constraints that you have to keep at all times.

.Tree data structures constraints
1. *Loops*: You have to be careful to not do a circular loop, otherwise this wouldn’t be a tree but a *graph data structure*! E.g. Node A has B as child, then Node B list Node A as its descendant forming a loop. ‍️
2.  *Parents*: A node with more than two parents. If that happens is no longer a tree but a graph.
3.  *Root*: a tree must have only one root. Two non-connected parts are not a tree. Graph can have non-connected parts and doesn’t have root.

== Basic concepts

.Here’s summary of the tree basic concepts:
* The top most node is called *root*.
* A node’s immediate linked nodes are called *children*.
* A *leaf* or *terminal node* is a node without any descendent or children.
* A node immediate ancestor is called *parent*. Yeah, like a family tree ‍‍‍ you can have *uncles* and *siblings*, and *grandparents*.
* *Internal nodes* are all nodes except for the leaf nodes and root node.
* The connection/link between nodes is called *edge*.
* The *height of a tree* is the distance, edge count, from the farthest leaf to the root. You can also calculate the *height of a node* counting the edges between them and the farthest leaf. For instance, from the image above:

* Node A, has a height of 3.
* Node G has a height of 1.
* Node I, has a height of 0.

* The *depth* *of a tree* is the distance, edge count, from the root to the farthest leaf.

.Tree anatomy
image:image31.jpg[image]

== Types of Binary Trees

There are different kinds of trees depending on the restrictions. E.g. The trees that have at most two children are called *binary tree*, while trees with at most 3 children are called *Ternary Tree*. Since binary trees are most common we are going to cover them here and ternary tree and others in another chapter.

=== Binary Tree

The binary restricts the nodes to have at most 2 children. Trees in general can have 3, 4, 26 or more, but not binary trees.

.Binary tree has at most 2 children while non-binary trees can have more.
image:image32.png[image,width=321,height=193]


=== Binary Search Tree (BST)

BST has the same restriction as binary tree; each node has at most 2 children. Also, there’s another restriction: the left child’s value has to be less than the parent and the right child’s value has be bigger than the parent.

.BST left < parent < right, while non-BST can be in any order.
image:image33.png[image,width=348,height=189]


=== Binary Heap

The heap is a type of binary tree where the children values are higher (max-heap) than the parent but contrary to the BST the left child doesn’t have to be smaller than the right child.

.Heap vs BST, has max/min value in the root, while BST doesn’t.
image:image34.png[image,width=325,height=176]


For a *max-heap*, the root has the highest value. The heap guarantee as you go down by level the elements on higher levels has bigger values than the element on lower levels. The opposite is true for a *min-heap*. In a min-heap the lowest value is at the root and as you go down the lower levels has higher values than the ones above.

.`max-heap` keeps highest value at the top while min-heap keep the lowest at the root.
image:image35.png[image,width=258,height=169]


.Heap vs Binary Search Tree
****
Heap is better at finding max or min values in constant time *O(1)*, while a balanced BST is good a finding any element in *O(log n)*. Heaps are often used to implement priority queues while BST is used when you need every value sorted.
****

